Запуск проєкту:
Переконайтеся, що у вас встановлені Node.js та npm.
Клонуйте репозиторій проєкту і перейдіть в його директорію.
Встановіть залежності: npm install
Запустіть сервер розробки: npm run dev

Для запуску тестів використовуйте команду: npm run test

Тести:

Назва тесту: charactersList
Тип тесту: Unit-тест
Сценарій 1: Відображення імені персонажа
Опис: Перевіряє, чи відображається ім'я персонажа, переданого у список персонажів.
Передумови: Існує компонент CharactersList, який приймає список персонажів і відображає їх.
Кроки:
Ініціалізувати список персонажів, який містить одного персонажа з ім'ям "Luke Skywalker".
Відрендерити компонент CharactersList, обгорнутий у Provider для Redux і BrowserRouter.
Перевірити, що на екрані з'являється текст "Luke Skywalker".
Очікуваний результат: Текст "Luke Skywalker" відображається на екрані.

Назва тесту: flow
Тип тесту: Unit-тест
Сценарій 1: Відображення компонентів Flow
Опис: Перевіряє, чи правильно відображаються вузли і ребра на графіку.
Передумови: Існує компонент Flow, який приймає дані графу і відображає їх.
Кроки:
Створити макетні дані для графу, які містять два вузли з назвами "Node 1" і "Node 2" та одне ребро, що з'єднує ці вузли.
Відрендерити компонент Flow, передавши йому макетні дані.
Перевірити, що на екрані відображаються вузли з назвами "Node 1" і "Node 2".
Очікуваний результат: Вузли з назвами "Node 1" і "Node 2" відображаються на екрані.

Назва тесту: loadMoreButton
Тип тесту: Unit-тест
Сценарій 1: Відображення кнопки Load More
Опис: Перевіряє, чи відображається кнопка "Load More".
Передумови: Існує компонент LoadMoreButton, який приймає функцію onClick.
Кроки:
Створити макетну функцію onClick за допомогою jest.fn().
Відрендерити компонент LoadMoreButton, передавши йому макетну функцію onClick.
Перевірити, що на екрані з'являється текст "Load More".
Очікуваний результат: Текст "Load More" відображається на екрані.
Сценарій 2: Перевірка виклику функції onClick
Опис: Перевіряє, чи викликається функція onClick при натисканні на кнопку.
Передумови: Існує компонент LoadMoreButton, який приймає функцію onClick.
Кроки:
Створити макетну функцію onClick за допомогою jest.fn().
Відрендерити компонент LoadMoreButton, передавши йому макетну функцію onClick.
Імітувати клік на кнопці "Load More".
Перевірити, що функція onClick викликана один раз.
Очікуваний результат: Функція onClick викликається один раз при натисканні на кнопку.

Назва тесту: navigation
Тип тесту: Unit-тест
Сценарій 1: Відображення навігаційного посилання на Home
Опис: Перевіряє, чи відображається навігаційне посилання на головну сторінку.
Передумови: Існує компонент Navigation, який містить навігаційне посилання на головну сторінку.
Кроки:
Відрендерити компонент Navigation, обгорнутий у MemoryRouter для роботи з маршрутизацією.
Перевірити, що на екрані з'являється текст "Home".
Перевірити, що посилання на "Home" має атрибут href зі значенням "/".
Очікуваний результат: Текст "Home" відображається на екрані та має правильне посилання.

Назва тесту: fetchData
Тип тесту: Unit-тест
Сценарій 1: Успішне отримання даних
Опис: Перевіряє, чи функція fetchData успішно отримує дані з API.
Передумови: Існує функція fetchData, яка робить запит до API та повертає дані.
Кроки:
Створити макетні дані для результатів API.
Мокувати функцію axios.get для повернення макетних даних.
Викликати fetchData з тестовими параметрами.
Перевірити, що axios.get був викликаний з правильними параметрами.
Перевірити, що результат виклику fetchData відповідає очікуваним макетним даним.
Очікуваний результат: Функція fetchData отримує дані та повертає їх правильно.
Сценарій 2: Обробка помилок
Опис: Перевіряє, чи функція fetchData коректно обробляє помилки, які виникають при запиті до API.
Передумови: Існує функція fetchData, яка робить запит до API та повертає помилки у випадку невдачі.
Кроки:
Створити макетну помилку для результатів API.
Мокувати функцію axios.get для повернення макетної помилки.
Викликати fetchData з тестовими параметрами.
Перевірити, що axios.get був викликаний з правильними параметрами.
Перевірити, що результат виклику fetchData відповідає очікуваній макетній помилці.
Очікуваний результат:

Назва теста: createGraphData
Тип тесту: Unit-тест
Сценарій 1: Створення вузлів та ребер
Опис: Перевіряє, чи функція createGraphData правильно створює вузли та ребра для графа.
Передумови: Існує функція createGraphData, яка приймає ім'я героя та маппінг фільмів і кораблів, і повертає дані для графа.
Кроки:
Визначити ім'я героя та маппінг фільмів і кораблів.
Викликати функцію createGraphData з цими параметрами.
Задати очікувані вузли, що мають містити назви фільмів та кораблів, з відповідними позиціями на графі.
Задати очікувані ребра, що мають з'єднувати вузли героя з вузлами фільмів і вузлами кораблів.
Перевірити, що результуючі вузли від createGraphData відповідають очікуваним вузлам.
Перевірити, що результуючі ребра від createGraphData відповідають очікуваним ребрам.
Очікуваний результат: Функція createGraphData повертає правильні вузли та ребра для графа.

Назва тесту: groupByFilms
Тип тесту: Unit-тест
Сценарій 1: Групування кораблів за фільмами
Опис: Перевіряє, чи функція groupByFilms правильно групує кораблі за фільмами.
Передумови: Існує функція groupByFilms, яка приймає дані кораблів і список фільмів, і повертає маппінг фільмів з їх відповідними кораблями.
Кроки:
Визначити дані кораблів, кожен з яких належить до певного фільму (чи декількох).
Визначити список фільмів з їх відповідними ID та назвами.
Викликати функцію groupByFilms з цими даними.
Задати очікуваний маппінг фільмів з їх відповідними кораблями.
Перевірити, що результат виклику groupByFilms відповідає очікуваному маппінгу.
Очікуваний результат: Функція groupByFilms повертає маппінг фільмів з їх відповідними кораблями правильно.

Назва тесту: getFilmsData
Тип тесту: Unit-тест
Сценарій 1: Успішне отримання даних про фільми
Опис: Перевіряє, чи функція getFilmsData успішно отримує дані з API і диспатчить fulfilled action.
Передумови: Існує функція getFilmsData, яка робить запит до API і повертає дані про фільми.
Кроки:
Створити макетні дані для результатів API, що містять список фільмів.
Мокувати функцію fetchData для повернення макетних даних.
Викликати getFilmsData з тестовими параметрами через mockStore.
Перевірити, що результат виклику має тип fulfilled.
Перевірити, що результат виклику містить очікувані дані про фільми.
Очікуваний результат: Функція getFilmsData диспатчить fulfilled action і повертає правильні дані про фільми.
Сценарій 2: Обробка помилок при запиті даних про фільми
Опис: Перевіряє, чи функція getFilmsData коректно обробляє помилки, що виникають при запиті до API, і диспатчить rejected action.
Передумови: Існує функція getFilmsData, яка робить запит до API і повертає помилки у випадку невдачі.
Кроки:
Створити макетну помилку для результатів API.
Мокувати функцію fetchData для повернення макетної помилки.
Викликати getFilmsData з тестовими параметрами через mockStore.
Перевірити, що результат виклику має тип rejected.
Перевірити, що результат виклику містить очікувану помилку.
Очікуваний результат: Функція getFilmsData диспатчить rejected action і повертає правильну помилку.

Назва тесту: getGraphData
Тип тесту: Unit-тест
Сценарій 1: Успішне отримання даних для графа
Опис: Перевіряє, чи функція getGraphData успішно отримує дані з API і диспатчить fulfilled action.
Передумови: Існує функція getGraphData, яка робить запит до API і повертає дані для побудови графа.
Кроки:
Створити макетні дані для результатів API, що містять список кораблів і фільмів.
Мокувати функцію fetchData для повернення макетних даних.
Викликати getGraphData з тестовими параметрами через mockStore.
Перевірити, що результат виклику має тип fulfilled.
Перевірити, що результат виклику містить очікувані дані для побудови графа, включаючи вузли та ребра.
Очікуваний результат: Функція getGraphData диспатчить fulfilled action і повертає правильні дані для побудови графа.
Сценарій 2: Обробка помилок при запиті даних для графа
Опис: Перевіряє, чи функція getGraphData коректно обробляє помилки, що виникають при запиті до API, і диспатчить rejected action.
Передумови: Існує функція getGraphData, яка робить запит до API і повертає помилки у випадку невдачі.
Кроки:
Створити макетну помилку для результатів API.
Мокувати функцію fetchData для повернення макетної помилки.
Викликати getGraphData з тестовими параметрами через mockStore.
Перевірити, що результат виклику має тип rejected.
Перевірити, що результат виклику містить очікувану помилку.
Очікуваний результат: Функція getGraphData диспатчить rejected action і повертає правильну помилку.

Назва тесту: getOnePageList
Тип тесту: Unit-тест
Сценарій 1: Успішне отримання даних для однієї сторінки.
Опис: Перевіряє, чи функція getOnePageList успішно отримує дані з API і диспатчить fulfilled action.
Передумови: Існує функція getOnePageList, яка робить запит до API і повертає дані для списку.
Кроки:
Створити макетні дані для результатів API, що містять інформацію про наступну сторінку та результати.
Мокувати функцію fetchData для повернення макетних даних.
Викликати getOnePageList з тестовими параметрами через mockStore.
Перевірити, що результат виклику має тип fulfilled.
Перевірити, що результат виклику містить очікувані дані, включаючи наступну сторінку і результати.
Очікуваний результат: Функція getOnePageList диспатчить fulfilled action і повертає правильні дані для списку.
Сценарій 2: Обробка помилок при запиті даних для однієї сторінки
Опис: Перевіряє, чи функція getOnePageList коректно обробляє помилки, що виникають при запиті до API, і диспатчить rejected action.
Передумови: Існує функція getOnePageList, яка робить запит до API і повертає помилки у випадку невдачі.
Кроки:
Створити макетну помилку для результатів API.
Мокувати функцію fetchData для повернення макетної помилки.
Викликати getOnePageList з тестовими параметрами через mockStore.
Перевірити, що результат виклику має тип rejected.
Перевірити, що результат виклику містить очікувану помилку.
Очікуваний результат: Функція getOnePageList диспатчить rejected action і повертає правильну помилку.

Назва тесту: Redux Selectors
Тип тесту: Unit-тест
Сценарій 1: Вибір renderData
Опис: Перевіряє, чи селектор selectRenderData правильно вибирає renderData зі стану.
Передумови: Існує селектор selectRenderData, який вибирає renderData зі стану.
Кроки:
Визначити макетний стан, що містить renderData.
Викликати селектор selectRenderData з макетним станом.
Перевірити, що результат виклику відповідає очікуваному renderData.
Очікуваний результат: Селектор selectRenderData повертає правильне renderData.
Сценарій 2: Вибір page
Опис: Перевіряє, чи селектор selectPage правильно вибирає page зі стану.
Передумови: Існує селектор selectPage, який вибирає page зі стану.
Кроки:
Визначити макетний стан, що містить page.
Викликати селектор selectPage з макетним станом.
Перевірити, що результат виклику відповідає очікуваному page.
Очікуваний результат: Селектор selectPage повертає правильний page.
Сценарій 3: Вибір homePageEndpoint
Опис: Перевіряє, чи селектор selectHomePageEndpoint правильно вибирає homePageEndpoint зі стану.
Передумови: Існує селектор selectHomePageEndpoint, який вибирає homePageEndpoint зі стану.
Кроки:
Визначити макетний стан, що містить homePageEndpoint.
Викликати селектор selectHomePageEndpoint з макетним станом.
Перевірити, що результат виклику відповідає очікуваному homePageEndpoint.
Очікуваний результат: Селектор selectHomePageEndpoint повертає правильний homePageEndpoint.
Сценарій 4: Вибір filmsEndpoint
Опис: Перевіряє, чи селектор selectFilmsEndpoint правильно вибирає filmsEndpoint зі стану.
Передумови: Існує селектор selectFilmsEndpoint, який вибирає filmsEndpoint зі стану.
Кроки:
Визначити макетний стан, що містить filmsEndpoint.
Викликати селектор selectFilmsEndpoint з макетним станом.
Перевірити, що результат виклику відповідає очікуваному filmsEndpoint.
Очікуваний результат: Селектор selectFilmsEndpoint повертає правильний filmsEndpoint.
Сценарій 5: Вибір shipEndpoint
Опис: Перевіряє, чи селектор selectShipEndpoint правильно вибирає shipEndpoint зі стану.
Передумови: Існує селектор selectShipEndpoint, який вибирає shipEndpoint зі стану.
Кроки:
Визначити макетний стан, що містить shipEndpoint.
Викликати селектор selectShipEndpoint з макетним станом.
Перевірити, що результат виклику відповідає очікуваному shipEndpoint.
Очікуваний результат: Селектор selectShipEndpoint повертає правильний shipEndpoint.
Сценарій 6: Вибір error
Опис: Перевіряє, чи селектор selectError правильно вибирає error зі стану.
Передумови: Існує селектор selectError, який вибирає error зі стану.
Кроки:
Визначити макетний стан, що містить error.
Викликати селектор selectError з макетним станом.
Перевірити, що результат виклику відповідає очікуваному error.
Очікуваний результат: Селектор selectError повертає правильний error.
Сценарій 7: Вибір імені персонажа
Опис: Перевіряє, чи селектор selectCharacterName правильно вибирає ім'я персонажа.
Передумови: Існує селектор selectCharacterName, який витягує ім'я персонажа з state.
Кроки:
Створити макетний state.
Викликати селектор selectCharacterName з макетним state.
Перевірити, що результат виклику селектора відповідає очікуваному імені персонажа.
Очікуваний результат: Селектор selectCharacterName повертає правильне ім'я персонажа.
Сценарій 8: Вибір фільмів
Опис: Перевіряє, чи селектор selectFilms правильно вибирає фільми.
Передумови: Існує селектор selectFilms, який витягує фільми з state.
Кроки:
Створити макетний state.
Викликати селектор selectFilms з макетним state.
Перевірити, що результат виклику селектора відповідає очікуваним фільмам.
Очікуваний результат: Селектор selectFilms повертає правильні фільми.
Сценарій 9: Вибір даних графа
Опис: Перевіряє, чи селектор selectGraphData правильно вибирає дані графа.
Передумови: Існує селектор selectGraphData, який витягує дані графа з state.
Кроки:
Створити макетний state.
Викликати селектор selectGraphData з макетним state.
Перевірити, що результат виклику селектора відповідає очікуваним даним графа.
Очікуваний результат: Селектор selectGraphData повертає правильні дані графа.
Сценарій 10: Вибір стану завантаження
Опис: Перевіряє, чи селектор selectIsLoaded правильно вибирає стан завантаження.
Передумови: Існує селектор selectIsLoaded, який витягує стан завантаження з state.
Кроки:
Створити макетний state.
Викликати селектор selectIsLoaded з макетним state.
Перевірити, що результат виклику селектора відповідає очікуваному стану завантаження.
Очікуваний результат: Селектор selectIsLoaded повертає правильний стан завантаження.
Сценарій 11: Вибір наступної сторінки
Опис: Перевіряє, чи селектор selectNext правильно вибирає інформацію про наступну сторінку.
Передумови: Існує селектор selectNext, який витягує інформацію про наступну сторінку з state.
Кроки:
Створити макетний state.
Викликати селектор selectNext з макетним state.
Перевірити, що результат виклику селектора відповідає очікуваній інформації про наступну сторінку.
Очікуваний результат:

Назва тесту: stateSlice
Тип тесту: Unit-тест
Сценарій 1: Повернення початкового стану
Опис: Перевіряє, чи редюсер stateReducer правильно повертає початковий стан.
Передумови: Існує редюсер stateReducer, який приймає початковий стан і дію.
Кроки:
Викликати stateReducer з undefined станом і дією @@INIT.
Перевірити, що результат виклику редюсера відповідає початковому стану INITIAL_STATE.
Очікуваний результат: Редюсер stateReducer повертає початковий стан.
Сценарій 2: Обробка setPage дії
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє дію setPage.
Передумови: Існує дія setPage, яка збільшує номер сторінки в стані.
Кроки:
Створити попередній стан з page: 1.
Викликати редюсер stateReducer з попереднім станом і дією setPage.
Перевірити, що результат виклику редюсера містить page: 2.
Очікуваний результат: Редюсер stateReducer правильно збільшує номер сторінки на 1.
Сценарій 3: Обробка resetData дії
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє дію resetData.
Передумови: Існує дія resetData, яка очищає певні поля в стані.
Кроки:
Створити попередній стан з даними в renderData, помилкою в error.
Викликати редюсер stateReducer з попереднім станом і дією resetData.
Перевірити, що результат виклику редюсера містить очищені renderData, error та graphData.
Очікуваний результат: Редюсер stateReducer правильно очищає дані в стані.
Сценарій 4: Обробка setCharacterName дії
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє дію setCharacterName.
Передумови: Існує дія setCharacterName, яка встановлює нове ім'я персонажа і змінює інші поля стану.
Кроки:
Створити попередній стан з іменем персонажа Old Name.
Викликати редюсер stateReducer з попереднім станом і дією setCharacterName.
Перевірити, що результат виклику редюсера містить нове ім'я персонажа і змінені поля isLoaded і page.
Очікуваний результат: Редюсер stateReducer правильно встановлює нове ім'я персонажа і змінює інші поля стану.
Сценарій 5: Обробка resetFilmData дії
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє дію resetFilmData.
Передумови: Існує дія resetFilmData, яка очищає дані про фільми в стані.
Кроки:
Створити попередній стан з даними про фільми.
Викликати редюсер stateReducer з попереднім станом і дією resetFilmData.
Перевірити, що результат виклику редюсера містить очищені дані про фільми.
Очікуваний результат: Редюсер stateReducer правильно очищає дані про фільми в стані.

Назва тесту: extraReducers in stateSlice
Тип тесту: Unit-тест
Сценарій 1: Обробка getOnePageList.fulfilled
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє fulfilled action для getOnePageList
Передумови: Існує редюсер stateReducer, який обробляє fulfilled action для getOnePageList.
Кроки:
Створити попередній стан без даних для рендеру.
Визначити payload з інформацією про наступну сторінку і результати.
Викликати редюсер з попереднім станом і fulfilled action для getOnePageList.
Перевірити, що новий стан містить інформацію про наступну сторінку і результати.
Очікуваний результат: Редюсер правильно обробляє fulfilled action і оновлює стан.
Сценарій 2: Обробка getOnePageList.rejected
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє rejected action для getOnePageList.
Передумови: Існує редюсер stateReducer, який обробляє rejected action для getOnePageList.
Кроки:
Створити попередній стан без помилки.
Викликати редюсер з попереднім станом і rejected action для getOnePageList.
Перевірити, що новий стан містить помилку.
Очікуваний результат: Редюсер правильно обробляє rejected action і оновлює стан з помилкою.
Сценарій 3: Обробка getFilmsData.fulfilled
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє fulfilled action для getFilmsData.
Передумови: Існує редюсер stateReducer, який обробляє fulfilled action для getFilmsData.
Кроки:
Створити попередній стан без даних про фільми.
Визначити payload з даними про фільми.
Викликати редюсер з попереднім станом і fulfilled action для getFilmsData.
Перевірити, що новий стан містить дані про фільми.
Очікуваний результат: Редюсер правильно обробляє fulfilled action і оновлює стан з даними про фільми.
Сценарій 4: Обробка getFilmsData.rejected
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє rejected action для getFilmsData.
Передумови: Існує редюсер stateReducer, який обробляє rejected action для getFilmsData.
Кроки:
Створити попередній стан без помилки.
Викликати редюсер з попереднім станом і rejected action для getFilmsData.
Перевірити, що новий стан містить помилку.
Очікуваний результат: Редюсер правильно обробляє rejected action і оновлює стан з помилкою.
Сценарій 5: Обробка getGraphData.fulfilled
Опис: Перевіряє, чи редюсер stateReducer правильно обробляє fulfilled action для getGraphData.
Передумови: Існує редюсер stateReducer, який обробляє fulfilled action для getGraphData.
Кроки:
Створити попередній стан без даних графа і з ненавантаженим станом.
Визначити payload з даними графа і ім'ям персонажа.
Викликати редюсер з попереднім станом і fulfilled action для getGraphData.
Перевірити, що новий стан містить дані графа, ім'я персонажа і завантажений стан.
Очікуваний результат: Редюсер правильно обробляє fulfilled action і оновлює стан з даними графа.
